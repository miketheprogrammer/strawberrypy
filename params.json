{"name":"Strawberrypy","tagline":"StrawberryPy","body":"Strawberry Py\r\n---------------\r\n\r\nStrawberry Py is a lightweight RESTFull (No Auth Yet) API Server. It is fast, efficient, and simple. Thats all.\r\n\r\nThis version of Strawberry Py also includes my MongoDB Relational Mapper and schema versioner called Mongitude\r\n\r\nWhile both StrawberryPy and Mongitude are far from finished they sport some interesting functionality.\r\n\r\nInstalling\r\n----------\r\n- MUST HAVE MONGO DB INSTALLED\r\n- clone the repo\r\n- `git clone git@github.com:miketheprogrammer/strawberrypy.git`\r\n\t- `cd strawberrypy`\r\n- run `sudo python setup.py install`\r\n\t- This will install dependencies [CherryPy, PyMongo]\r\n\r\n\r\nStarting the Server\r\n-------------------\r\nThere is a demo application in the application folder\r\n- run `python application/start.py`\r\n- wait for it to start then exit out of it, softly with cntr + c\r\n- run `python application/initial_data.py`\r\n- run `python application/start.py`\r\n\r\nReason for this is we need to do an initial schema migration.\r\nAfter which we can load data.\r\n\r\n\r\nThe Request\r\n-----------\r\nExample GET Request\r\n\r\n- `http://localhost:8007/users/` GETS all users\r\n\r\n\tThe Response ( this reponse is truncated because it was way too long. Also it has debug enabled so it prints the query data)\r\n\t------------\r\n\r\n\r\n`EXAMPLE ONLY Displays user0`\r\n```PYTHON\r\nQUERY :{\"_revision_id\": \"5100489086a955305e447047\"}\r\nParams :{\"_revision_id\": \"5100489086a955305e447047\"}\r\nPATH :\"/users\"\r\n\r\n[\r\n\t{\r\n\t\t\"username\": \"user0\", \r\n\t\t\"_revision_id\": \"5100489086a955305e447047\", \r\n\t\t\"name\": \"surname0, first0\", \r\n\t\t\"age\": 0, \r\n\t\t\"_id\": \"5100489386a95530739473bc\", \r\n\t\t\"likes\": \r\n\t\t\t[\r\n\t\t\t\t{\r\n\t\t\t\t\t\"username\": \"user0\", \r\n\t\t\t\t\t\"item\": \"item0\", \r\n\t\t\t\t\t\"is_liked\": 1, \r\n\t\t\t\t\t\"_id\": \"5100489386a95530739473bd\", \r\n\t\t\t\t\t\"_revision_id\": \"5100489086a955305e447048\"\r\n\t\t\t\t}, \r\n\t\t\t\t{\r\n\t\t\t\t\t\"username\": \"user0\", \r\n\t\t\t\t\t\"item\": \"item1\", \"is_liked\": 0, \r\n\r\n\t\t\t\t\t.......etcetera\r\n```\r\n\r\nTightening the search\r\n-----------\r\nExample GET Request\r\n\r\n- `http://localhost:8007/users/username/user0` \r\n\t- `Returns a subset of the users where username = user0`\r\n\r\nFollowing the object hierarchy\r\n------------------------------\r\nWe see that users have likes attributed between them and an item, thats interesting\r\nWhat if we want to find all items that the user has liked\r\n\r\n- `http://localhost:8007/likes/username/user0/is_liked/1`\r\n\r\n\tThe Response ()\r\n\t------------\r\n\t```PYTHON\r\nQUERY :{\"username\": \"user0\", \"is_liked\": 1, \"_revision_id\": \"514b33f286a955572d88c4d7\"}\r\nParams :{\"username\": \"user0\", \"is_liked\": 1, \"_revision_id\": \"514b33f286a955572d88c4d7\"}\r\n PATH :\"/likes/username/user0/is_liked/1\"\r\n\t[\r\n\t\t{\r\n\t\t\t\"username\": \"user0\", \r\n\t\t\t\"item\": \"item0\", \r\n\t\t\t\"is_liked\": 1, \r\n\t\t\t\"_id\": \"5100489386a95530739473bd\", \r\n\t\t\t\"_revision_id\": \"5100489086a955305e447048\"}, \r\n\t\t{\r\n\t\t\t\"username\": \"user0\", \r\n\t\t\t\"item\": \"item4\", \r\n\t\t\t\"is_liked\": 1, \r\n\t\t\t\"_id\": \"5100489386a95530739473c1\", \r\n\t\t\t\"_revision_id\": \"5100489086a955305e447048\"}, \r\n\t\t{\r\n\t\t\t\"username\": \"user0\", \r\n\t\t\t\"item\": \"item6\", \r\n\t\t\t\"is_liked\": 1, \r\n\t\t\t\"_id\": \"5100489386a95530739473c3\", \r\n\t\t\t\"_revision_id\": \"5100489086a955305e447048\"}, \r\n\t]\r\n\t```\r\n\r\nCreating a new Model or known in Strawberry as a Document.\r\n---------------------------------------------------------\r\n\r\n- Necessary Imports\r\n\r\n```PYTHON\r\nfrom strawberry.core.database.mongitude.base import connection, documents, schema, encoders\r\nfrom bson import ObjectId\r\n```\r\n- Creating the User Document\r\n```PYTHON\r\nclass UserDocument(documents.RevisionedDocument):\r\n    class Meta(object):\r\n        required_fields = ['username']\r\n        related_to = {'likes': (LikesDocument, 'username')}\r\n        indexes = {'username':\r\n                            {\r\n                                'name':'_username_idx_',\r\n                                'unique':True,\r\n                                'dropDups':True,\r\n                            },\r\n                  }\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        self._id = ObjectId\r\n        self.username = str\r\n        self.name = str\r\n        self.age = int\r\n        self.likes = list\r\n        super(self.__class__, self).__init__(collection_name='users', **kwargs)\r\n\r\n\r\n\r\nUnderstanding the Document\r\n--------------------------\r\n\r\nAll documents have a `class Meta(object)` which describes important information\r\nincluding relational structure\r\n- Understanding Meta\r\n\t- related_to : `related_to = {'likes': (LikesDocument, 'username')}`\r\n\t\t- In this case it indicates this class has a child likes composed of a document LikesDocument, related on field `username`\r\n\t- indexes : `Creates indexes on the keys listed, all parameters are natural pymongo and in turn mongo db parameters`\r\n\r\n\r\n- Understanding __init__\r\n\t- Each field declared here is a description of schema, in order for naive-validation to work, the field must be equal to its type\r\n\r\n\t- super...blah...collection_name='users'\r\n\t\t- Says to use db.users as the collection. i.e. `main.users`\r\n\r\n\r\n\r\nExample of Multiple indexes\r\n---------------------------\r\n```PYTHON\r\nclass LikesDocument(documents.RevisionedDocument):\r\n    class Meta(object):\r\n        required_fields = []\r\n        indexes = {'username':\r\n                            {\r\n                                'name':'_username_idx_',\r\n                                'unique':False,\r\n                                'dropDups':False,\r\n                            },\r\n                    'item': {\r\n                                'name':'_item_idx_',\r\n                                'unique':False,\r\n                                'dropDups':False\r\n                            },\r\n                    'is_liked': {\r\n                                'name':'_isliked_idx_',\r\n                                'unique':False,\r\n                                'dropDups':False\r\n                            },\r\n                  }\r\n```\r\n\r\n- Composite Indexes are not supported yet.\r\n\r\n\r\nCREATING a controller\r\n---------------------\r\n\r\n```PYTHON\r\nfrom strawberry.core.base import BaseController\r\nfrom strawberry.core.database.mongitude.base import encoders\r\nimport strawberry.core.serializers\r\nimport documents\r\n```\r\n\r\n```PYTHON\r\nclass UserController(BaseController):\r\n    default_message = 'no users'\r\n    collection = documents.UserDocument\r\n\r\n\r\n    def get(self):\r\n        self.query = self.params\r\n        results = self.collection.find(self.query)\r\n        json_response = strawberry.core.serializers.serialize_list(results)\r\n        self.response_headers = [('Content-type', 'text/plain'), ('Cache-Control',('max-age=100'))]\r\n        super(UserController, self).get()\r\n\r\n        return self.get_debug() + json_response\r\n\r\n    def post(self):\r\n        return self.get()\r\n        return 'GET ' + json_response\r\n```\r\n\r\nUNDERSTANDING a controller\r\n--------------------------\r\n```PYTHON\r\nclass UserController(BaseController):\r\n    default_message = 'no users'\r\n    collection = documents.UserDocument\r\n```\r\n\t- default_message: What message to display if there are no records found.\r\n\t- collection : the model to use\r\n\r\n```PYTHON\r\n    def get(self):\r\n        self.query = self.params\r\n        results = self.collection.find(self.query)\r\n        json_response = strawberry.core.serializers.serialize_list(results)\r\n        self.response_headers = [('Content-type', 'text/plain'), ('Cache-Control',('max-age=100'))]\r\n        super(UserController, self).get()\r\n```\r\n\t- Refer to \r\n\t\t```PYTHON\r\n\t\tresults = self.collection.find(self.query)\r\n\t\t```\r\n\t\t- This call returns a collection of documents as objects, not as json\r\n\r\n\t- Refer to the line\r\n\t\t```PYTHON\r\n\t\tjson_response = strawberry.core.serializers.serialize_list(results)\r\n\t\t```\r\n\t\t- Included in strawberry is a special serializer for converting between objects and mongodb.\r\n\r\n\r\nCreating a new Application\r\n--------------------------\r\n \r\n```BASH\r\nmkdir appname\r\ncd appname\r\ntouch controllers.py\r\ntouch documents.py\r\ntouch start.py\r\n```\r\n\r\nCREATING start.py\r\n-----------------\r\nAssumes you have controllers and documents\r\n\r\n```PYTHON\r\nimport strawberry\r\nimport controllers\r\nimport documents\r\n\r\nstrawberry.core.server.load_route(r'',controllers.IndexController)\r\nstrawberry.core.server.load_route(r'^/users', controllers.UserController)\r\nstrawberry.core.server.load_route(r'^/likes', controllers.LikesController)\r\nstrawberry.core.server.load_route(r'^/realusers', controllers.RealUserController)\r\n\r\nstrawberry.core.server.register_model(documents.UserDocument)\r\nstrawberry.core.server.register_model(documents.LikesDocument)\r\nstrawberry.core.server.register_model(documents.RealUserDocument)\r\n\r\nstrawberry.core.server.server(host='0.0.0.0', port=80).start()\r\n```\r\n\r\nUNDERSTANDING start.py\r\n----------------------\r\n\r\n`load_route` takes a regexp route, and a controller to use\r\n\r\n`register_model` simply registers the model for use, and will automatically migrate all registered models.\r\n\r\n`server().start()`\r\n\t- default host is `0.0.0.0`\r\n\t- default port is `8007`\r\n``\r\n\r\n\r\nDIGGIN DEEPER\r\n-------------\r\n- Understanding how migrations work.\r\n------------------------------------\r\n\r\nFirstly, all documents that want to be revisioned must inherit from\r\nRevisionedDocument. This creates a field called _revision_id\r\n\r\nWhen the server starts it compares all registered documents schemas\r\nwith the schema stored in the revisions collection.\r\n\r\nThe Following code is how its done. It's simple but efficient\r\n```PYTHON\r\n<<Start Code Segment>>\r\nset_a = set(revision['_schema'].items())\r\nset_b = set(instance.schema.get_comparable().items())\r\ndiff =  set_a - set_b\r\ndiff2 = set_b - set_a \r\nif len(diff) == 0 and len(diff2) == 0:\r\n\tprint 'Found Revision: %s \\n\\n' % str(revision['_id'])\r\n\treturn True\r\n<<End Code Segment>>\r\n```\r\n\r\n- We get two sets, which allow mathematical operations on them.\r\n  Get the diffs, and compare.\r\n  If either diff is != 0 in length we have an incomaptibility issue.\r\n\r\nOTHERWISE WE:\r\n\r\n```PYTHON\r\nif revision is not None:\r\n\tversion = int(revision['_version']) + 1\r\nelse:\r\n\tversion = 0\r\nprint 'Current Version: %s ' % str(version)\r\n_revision = RevisionHistoryDocument()\r\n_revision._version = version\r\n_revision._collection = instance.collection_name\r\n_revision._schema = instance.schema.get_comparable()\r\n\r\n_revision.save()\r\nprint 'New Revision for: %s \\n\\n' % str(instance.__class__)\r\n```\r\n- UNDERSTANDING serializers.serialize_list\r\n------------------------------------------\r\n```PYTHON\r\nFunction Incomplete as of writing this.\r\nOnly works 2 levels deep, doesnt recurse the whole object hierarchy\r\nAlso terminology is off.\r\n\r\ndef serialize_list(lst):\r\n    field_list = []\r\n    for model in lst:\r\n        if hasattr(model.Meta, 'related_to'):\r\n            for k, v in model.Meta.related_to.items():\r\n                attr = getattr(model, k)\r\n                if isinstance(attr, list):\r\n                    new_list = []\r\n                    for like in attr:\r\n                        new_list.append(like.fields)\r\n                    setattr(model, k, new_list)\r\n        field_list.append(model.fields)\r\n    return encoders.MongoEncoder().encode(field_list)\r\n```\r\nThe function simply recurses over the object getting attributes and appending to list. Then passes it to encoders.MongoEncoder().encode()\r\n\r\n```PYTHON\r\nfrom json import JSONEncoder\r\nfrom bson import ObjectId\r\nclass MongoEncoder(JSONEncoder):\r\n    def default(self, obj, **kwargs):\r\n        if isinstance(obj, ObjectId):\r\n            return str(obj)\r\n        else:\r\n            return JSONEncoder.default(obj, **kwargs)\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}